@charset "UTF-8";

/// Applies the micro clearfix hack popularized by Nicolas Gallagher. Include this mixin on a container if its children are all floated, to give the container a proper height.
/// The clearfix is augmented with specific styles to prevent borders in flexbox environments
/// @link http://nicolasgallagher.com/micro-clearfix-hack/ Micro Clearfix Hack
/// @link http://danisadesigner.com/blog/flexbox-clear-fix-pseudo-elements/ Flexbox fix

// -----------------------------------------------------
// Clearfix
// -----------------------------------------------------

%clearfix {
  &::before,
  &::after {
    content: " ";
    display: table;
    flex-basis: 0;
    order: 1;
  }
  &:after {
    clear: both;
  }
}

// -----------------------------------------------------
// Size
// -----------------------------------------------------

@mixin wrapper($wrapper-width: 100%) {
  max-width: $wrapper-width;
  margin: 0 auto;
  @extend %clearfix;
}

@mixin container($width: 100%, $padding: 0, $margin: 0) {
  flex: 1;
  max-width: $width;
  padding: $padding;
  margin: $margin;
}

/// Sizing helper
@mixin size($width, $height: auto) {
  max-width: $width;
  height: $height;
}

// -----------------------------------------------------
// Position
// -----------------------------------------------------

/// Shorthandizes position declarations.
/// @param {String} $type - Either `relative`, `absolute` or `fixed`
/// example:  @include position(absolute, $top: 10px, $left: 10px);
@mixin position($type, $top: null, $right: null, $bottom: null, $left: null) {
  position: $type;
  top: $top;
  right: $right;
  bottom: $bottom;
  left: $left;
}

// -----------------------------------------------------
// Flexbox
// -----------------------------------------------------

// Flex
@mixin flex {
  display: flex;
}

// Flex order
@mixin flex-order($order: 0) {
  order: $order;
}

$-content: (
  'left': flex-start,
  'right': flex-end,
  'center': center,
  'justify': space-between,
  'space': space-around,
  );

$-items: (
  'top': flex-start,
  'bottom': flex-end,
  'center': center,
  'stretch': stretch,
  );

// Flex $x = (horizontal alignment) + $y  = (vertical alignment)
@mixin flex-align($x: null, $y: null){
  display: flex;
  @if $x {
    @if map-has-key($-content, $x) {
      $x: map-get($-content, $x);
    }
    @else {
      @warn '[$x], $y: For justify-content: left, right, center, justify, or spaced'
    }
  }

  @if $y {
    @if map-has-key($-items, $y) {
      $y: map-get($-items, $y);
    }
    @else {
      @warn '$x, [$y]: For align-items: use top, bottom, center or stretch'
    }
  }

  justify-content: $x;
  align-items: $y;
}

/* Used to convert PX to EMs for multiple properties or values or both.
$base is an optional measurement that allows making measurements relative to the parent font size rather than the current. Also accepts a list of lists (instead a list of values) for properties that accept multiple lists of values. Only numbers of converted; everything else is passed through.
Examples:
@include scale(line-height, 30)
@include scale(line-height, 30, 16)
@include scale(width height, 125);
@include scale(padding, 0 25, 16);
@include scale(text-shadow, (#0d6e28 1 1) (#777 0 0 2), 16);
@include scale(box-shadow, (inset 0 0 0 1 #2a9022) (inset 0 0 3 #459966), 16);
*/
@mixin scale($props, $sizes, $base: $base-font-size) {
  $values: ();
  $sublists: false;
  @each $s in $sizes {
    /* unwrap lists for values that have multiple list of values such as text-shadow */
    @if type-of($s) == list {
      $sublists: true;
      $vv: ();
      @each $ss in $s {
        $vv: append($vv, if(type-of($ss) == number, #{$ss / $base}em, $ss));
      }
      $values: append($values, join((), $vv));
      } @else {
        $values: append($values, if(type-of($s) == number, #{$s / $base}em, $s));
      }
    }
    $value: join((), $values, if($sublists, comma, space));
    @each $prop in $props { #{$prop}: $value }
  }

// -----------------------------------------------------
// Responsive Breakpoints
// -----------------------------------------------------

// @include breakpoint(large) { width: 60%; }
// @include breakpoint(medium) { width: 80%; }
// @include breakpoint(small) { width: 95%; }

@mixin breakpoint($point) {
  @if $point == large {
    @media (min-width: 64.375em) { @content; }
  }
  @else if $point == medium {
    @media (min-width: 50em) { @content; }
  }
  @else if $point == small {
    @media (min-width: 37.5em)  { @content; }
  }
}

// -----------------------------------------------------
// Colors
// -----------------------------------------------------

/// Given an opacity value, generates that value as well as a way to display that opacity value in Internet Explorer 8 and 9.
@mixin opacity($opacity) {
  opacity: $opacity;
  $opacity-ie: $opacity * 100;
  filter: alpha(opacity=$opacity-ie); //IE8
  -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=#{$opacity * 100})";
}

// -----------------------------------------------------
// Images
// -----------------------------------------------------

/// Retina image media query helper; given an image path with a 2x-sized version of an image, will load that image as a background-image on high-resolution devices.
///     @include image-2x('../images/image.png', 100%, auto);
@mixin image-2x($image, $width, $height) {
  @media (min--moz-device-pixel-ratio: 1.3),
         (-o-min-device-pixel-ratio: 2.6/2),
         (-webkit-min-device-pixel-ratio: 1.3),
         (min-device-pixel-ratio: 1.3),
         (min-resolution: 1.3dppx) {
    /* on retina, use image that's scaled by 2 */
    background-image: url($image);
    background-size: $width $height;
  }
}

// -----------------------------------------------------
// Typography
// -----------------------------------------------------

// reproduces that font size in ems
@mixin font-size($size) {
  font-size: font-px($size);
}

/// Generates line-height values in both pixels and rems.
@mixin line-height($height-value: 12) {
    line-height: $height-value * 1px; //fallback for old browsers
    line-height: (1 / ($base-font-size / ($base-font-size * 0 + 1)) * $height-value * 1em);
  }

/// Given the location of a webfont, will generate a font-face declaration with multiple file formats.
@mixin font-face($font-name, $file-name, $weight: normal, $style: normal) {
  @font-face {
    font-family: quote($font-name);
    src: url($file-name + '.eot');
    src: url($file-name + '.eot?#iefix')  format('embedded-opentype'),
    url($file-name + '.woff') format('woff'),
    url($file-name + '.ttf')  format('truetype'),
    url($file-name + '.svg##{$font-name}')  format('svg');
    font-weight: $weight;
    font-style: $style;
  }
}

// -----------------------------------------------------
// Transition
// -----------------------------------------------------

/// Transition helper
// example @include transition(0.3s, ease-in);
@mixin transition($time: 1s, $timing-function: ease-in-out) {
  @include prefix(transition, all $time $timing-function, 'webkit');
}

/// Slide-in-from creates and calls an animation that slides an element on a given axis for a given amount of space.
// example @include slide-in-from(y, -200px, 3s ease alternate infinite);
@mixin slide-in-from($slide-axis: x, $slide-offset: -100px, $animation-properties: 3s ease-out) {
  $slide-start: if($slide-axis == x, translateX($slide-offset), translateY($slide-offset));
  $slide-end: if($slide-axis == x, translateX(0), translateY(0));

  @include keyframes(slide-in-#{$slide-axis}-#{$slide-offset}){
    0% {
      @include opacity(0);
      @include transform($slide-start);
    }
    75% {
      @include transform($slide-end);
    }
    100% {
      @include opacity(1);
    }
  }

  @include prefix(animation, slide-in-#{$slide-axis}-#{$slide-offset} $animation-properties, 'webkit');
}

